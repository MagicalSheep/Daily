# 分析

这是一道简单的线性DP。

首先通过观察，可知点的纵坐标y是不起作用的（我们可以将平台放置于纵坐标负无穷的位置）。通过对剩下的横坐标x进行排序，我们在x轴上得到了一系列有序的点，这些有序的点就是线性DP的处理线索。

让我们先将问题简化，只使用一个平台，求所能接住的点的最大数量。此时，可作为状态的信息有：`x轴上有序的点`、`平台所能接住的点的数量`；而后者为题目所求，故状态设置呼之欲出——

$f(i)$表示处理到第i个点时，平台所能接住的点的最大数量。

如何进行状态转移呢？想象一个平台在x轴上从左往右滑动，总是试图接住第i个点。让我们设这个已接住了第i个点的平台此时一共接住了`cnt`个点，那么我们可以得到状态转移方程：

$f(i)=\max\{f(i-1),cnt\}$

现在我们需要放置两个平台，于是可以作为状态的信息增加了一个`已放置平台的个数`，于是本题的状态设置为——

$f(i,j)$表示处理到第i个点，已放置了j个平台时，所能接住的点的最大数量。（当然，j可以取0和1来分别代表放置了1和2个平台）

让我们设这个已接住了第i个点的平台此时一共接住了`cnt`个点，接住的第一个点是x轴上从左往右的第`k`个点，那么我们可以得到状态转移方程：

$\begin{cases}f(i,0)=\max\{f(i-1,0),cnt\}\\f(i,1)=\max\{f(i-1,1),f(k-1,0)+cnt\}\end{cases}$

如何求得`cnt`与`k`呢？可以参考滑动窗口的处理方式，从第一个点开始作为平台的左端点，由于长度确定，此时平台右端点也被确定，平台所能接住点的范围也就确定了。每加入一个点i，如果在平台所能接住点的范围内，`cnt`就加一；如果在范围外，就右移平台（左端点更改为下一个点），每右移一次`cnt`便减去一，直到点i能够被平台接住。`k`就是平台左端点。

# AC代码

```C++
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 2e5 + 10;

int t, n, k, x[MAXN], f[MAXN][2];

int main()
{
    scanf("%d", &t);
    while (t--)
    {
        scanf("%d%d", &n, &k);
        for (int i = 1; i <= n; i++)
            scanf("%d", &x[i]);
        for (int i = 1; i <= n; i++)
            scanf("%*d");
        sort(x + 1, x + 1 + n);
        for (int i = 1, j = 1, cnt = 1; i <= n; i++)
        {
            while (x[j] + k < x[i])
                ++j, --cnt;
            f[i][0] = max(f[i - 1][0], cnt);
            f[i][1] = max(f[i - 1][1], f[j - 1][0] + cnt);
            ++cnt;
        }
        printf("%d\n", f[n][1]);
    }
    return 0;
}
```